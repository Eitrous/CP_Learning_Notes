# 算法竞赛学习笔记

>任何一个有智力的笨蛋都可以把事情搞得更大，更复杂。往**相反的方向**前进则需要天分，以及很大的勇气。 <p align="right">——阿尔伯特·爱因斯坦</p>


- [算法竞赛学习笔记](#算法竞赛学习笔记)
- [语法篇](#语法篇)
  - [输入输出](#输入输出)
    - [标准输入输出](#标准输入输出)
      - [*scanf* 和 *printf*](#scanf-和-printf)
      - [*cin* 和 *cout*](#cin-和-cout)
      - [同步流](#同步流)
    - [sscanf() 和 sprintf()](#sscanf-和-sprintf)
    - [字符输入输出](#字符输入输出)
      - [getchar() 和 putchar()](#getchar-和-putchar)
    - [字符串输入输出](#字符串输入输出)
      - [gets() 和 puts()](#gets-和-puts)
      - [fgets() 和 fputs()](#fgets-和-fputs)
    - [文件输入输出](#文件输入输出)
      - [fopen() 和 fclose()](#fopen-和-fclose)
  - [一点小杂碎](#一点小杂碎)
    - [头文件](#头文件)
      - [\<assert.h\>](#asserth)
    - [常量设置](#常量设置)
      - [尽量用`const`而非`define`](#尽量用const而非define)
    - [开数组](#开数组)
      - [尽量开全局数组](#尽量开全局数组)
- [算法篇](#算法篇)
  - [前缀和与差分](#前缀和与差分)
    - [前缀和](#前缀和)
    - [差分](#差分)
    - [二分](#二分)
    - [贪心](#贪心)
      - [调整法贪心](#调整法贪心)
    - [排序](#排序)
      - [冒泡排序](#冒泡排序)
      - [选择排序](#选择排序)
      - [插入排序](#插入排序)
      - [希尔排序](#希尔排序)
      - [快速排序](#快速排序)
      - [归并排序](#归并排序)
      - [堆排序](#堆排序)
      - [基数排序](#基数排序)
- [数学篇](#数学篇)
  - [位运算](#位运算)
    - [种类](#种类)
    - [异或](#异或)
      - [性质](#性质)
    - [应用](#应用)
      - [状态压缩](#状态压缩)
      - [线性基](#线性基)
      - [高效运算](#高效运算)
      - [01串](#01串)
      - [计数](#计数)
- [数据结构篇](#数据结构篇)
  - [栈](#栈)
    - [性质](#性质-1)
    - [应用](#应用-1)
    - [数组模拟栈](#数组模拟栈)
  - [单调栈](#单调栈)
    - [性质](#性质-2)
    - [应用](#应用-2)
  - [队列](#队列)
    - [性质](#性质-3)
    - [双端队列](#双端队列)
    - [循环队列](#循环队列)
  - [优先队列](#优先队列)
  - [映射](#映射)
  - [set](#set)
  - [bitset ❗](#bitset-)
    - [使用](#使用)
- [其他篇](#其他篇)
  - [双指针](#双指针)

---

# 语法篇

## 输入输出

### 标准输入输出

#### *scanf* 和 *printf*
格式化输入输出

C标准流

**不能**取消同步流，否则会混乱

:construction_worker:***此处应添加转义字符表与格式化字符表***:construction_worker:

#### *cin* 和 *cout*

C++标准流

简洁，取消同步流后一般比scanf快

*尽量不要使用 `endl`[^1]，改用 `'\n'`*[^2]

`endl` = `'\n'` + 强制刷新缓冲区

[^1]: 写交互题时用`endl`可能更方便

[^2]:也可以用`"\n"`，只不过输出的是字符串


#### 同步流

O2优化时依然需要取消同步流

取消同步流：

```cpp
//一定要写完整
ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
```

### sscanf() 和 sprintf()

### 字符输入输出

#### getchar() 和 putchar()

### 字符串输入输出

#### gets() 和 puts()

#### fgets() 和 fputs()

### 文件输入输出

#### fopen() 和 fclose()

## 一点小杂碎

### 头文件

#### <assert.h>

### 常量设置

#### 尽量用`const`而非`define`

以下两种写法输出结果不同：

```cpp
#define N 1e5 + 10
int main()
{
    cout << N * 2 << '\n';//输出100020
    return 0;
}
```

```cpp
const long long N 1e5 + 10
int main()
{
    cout << N * 2 << '\n';//输出200020
    return 0;
}
```

***原因：`#define`只是简单的宏替换***

也可以使用

```cpp
#define N (1e5 + 10)
```

不过还是尽量用`const`吧

### 开数组

#### 尽量开全局数组

原因：
- 自动初始化为0
- 占用堆空间，可以开大数组

---
# 算法篇

## 前缀和与差分

### 前缀和
特点：
- 简化计算
- 要求运算方法具有可加性，如加法、乘法、异或

### 差分
特点：
- 可通过前缀和还原
- 后缀区间修改
- 静态的，不能边询问边修改
- 全部修改完成后再询问可达到 *O(1)* 复杂度

### 二分

### 贪心

#### 调整法贪心



### 排序

![八种排序及其复杂度](/sort.png)

#### 冒泡排序

#### 选择排序

#### 插入排序

#### 希尔排序

#### 快速排序

#### 归并排序

#### 堆排序

#### 基数排序

---
# 数学篇

## 位运算

### 种类

| 名称 | 符号 |
|:---:|:---:|
| 与 | & |
| 或 | \| |
| 非 | ! |
| 异或 | ^ |
| 移位 | << >> |
| 取反 | ~ |

### 异或

#### 性质

- 结合律
- 交换律
- 无分配律
- a ^ 0 = a
- a ^ a = 0
- a + b = 2*(a & b) + (a ^ b)

### 应用

#### 状态压缩

#### 线性基

#### 高效运算

#### 01串

#### 计数

---
# 数据结构篇

## 栈

### 性质
- 先进后出
- **常用函数**
  - 访问
    - `st.top()` 返回栈顶
  - 修改
    - `st.push()` 插入元素到栈顶
    - `st.pop()` 弹出栈顶元素
  - 容量
    - `st.empty()` 返回是否为空
    - `st.size()` 返回元素数量
- **常用运算符**
  - `=` 赋值

### 应用
- 实战中经常使用**数组模拟栈**，因为数组操作更快，可进行的操作更多

### 数组模拟栈

## 单调栈

### 性质
- 满足单调性的栈结构
- 插入元素时通过弹出部分栈内元素来维护单调性


### 应用
- 从栈顶读出一个元素，其满足单调性的某一端

## 队列

### 性质
- 先进先出
- **常用函数**
  - 访问
    - `q.front()` 返回队首元素
    - `q.back()` 返回队尾元素
  - 修改
    - `q.push()` 在队尾插入元素
    - `q.pop()` 弹出队首元素
  - 容量
    - `q.empty()` 队列是否为空
    - `q.size()` 返回队列中元素的数量
  
### 双端队列
- 在队尾和队首都能进行插入和删除操作
- **常用函数**
  - 访问
    - `q.front()` 返回队首元素
    - `q.back()` 返回队尾元素
  - 修改
    - `q.push_back()` 在队尾插入元素
    - `q.pop_back()` 弹出队尾元素
    - `q.push_front()` 在队首插入元素
    - `q.pop_front()` 弹出队首元素
    - `q.insert()` 在指定位置前插入元素（传入迭代器和元素）
    - `q.erase()` 删除指定位置的元素（传入迭代器）
  - 容量
    - `q.empty()` 队列是否为空
    - `q.size()` 返回队列中元素的数量
- **常用运算符**
  - `=` 赋值
  - `[]` 访问元素

### 循环队列
- 将下标为 0 的位置看做是最后一个位置的后继
- 用于解决数组模拟队列时的“假溢出”问题

## 优先队列
- 默认大根堆
- **常用函数**
  - 访问
    - `pq.top()` 访问堆顶元素
  - 修改
    - `pq.push()` 插入元素并排序
    - `pq.pop()` 删除堆顶元素
  - 容量
    - `pq.empty()` 容器是否为空
    - `pq.size()` 返回容器中元素数量

## 映射

## set

## bitset ❗

### 使用

- `count()` 返回1的个数
- `reset()` 全部变为0 


---

# 其他篇

## 双指针


